<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="utf-8" />
    <title>Cross-Reveal + Stepwise Parallax Cover</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/gsap.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/ScrollTrigger.min.js"></script>
    <style>
      * {
        box-sizing: border-box;
        margin: 0;
      }
      body {
        font-family: system-ui, -apple-system, Segoe UI, Roboto, Noto Sans,
          sans-serif;
        background: #0a0c11;
        color: #e6ebff;
      }
      .spacer {
        height: 60vh;
        display: grid;
        place-items: center;
        color: #93a2c7;
      }

      /* 핀되는 스테이지 */
      .pin-wrap {
        height: 100vh;
        display: grid;
        place-items: center;
        position: relative;
        overflow: clip;
      }
      .stage {
        position: relative;
        width: min(86vw, 1100px);
        aspect-ratio: 16/9;
        border-radius: 16px;
        overflow: hidden;
        box-shadow: 0 12px 36px rgba(0, 0, 0, 0.35);
        background: #000;
      }
      .stage img {
        position: absolute;
        inset: 0;
        width: 100%;
        height: 100%;
        object-fit: cover;
        transform: translateY(0%);
        will-change: transform;
      }
      /* 쌓이는 순서(위→아래) */
      .stage img:nth-child(1) {
        z-index: 5;
      }
      .stage img:nth-child(2) {
        z-index: 4;
      }
      .stage img:nth-child(3) {
        z-index: 3;
      }
      .stage img:nth-child(4) {
        z-index: 2;
      }
      .stage img:nth-child(5) {
        z-index: 1;
      }

      /* 실제 다음 섹션 */
      .next {
        background: #f7f4ea;
        color: #1b1b1b;
        min-height: 140vh;
        padding: clamp(28px, 6vw, 64px) 6vw;
        position: relative;
        z-index: 0;
        will-change: transform;
        /* 덮어쓰기 효과를 위한 그림자 */
        box-shadow: 0 -20px 40px rgba(0, 0, 0, 0.1);
        border-radius: 20px 20px 0 0;
        /* 더 명확한 덮어쓰기를 위한 배경 */
        background: linear-gradient(to bottom, #f7f4ea, #f0ede0);
        /* 확실히 보이도록 설정 */
        display: block;
        visibility: visible;
      }
      .next.is-overlay {
        position: fixed;
        inset: 0;
        z-index: 50; /* 모든 이미지보다 위에 오도록 */
        transform: translateY(100%);
        /* 덮어쓰기 모드에서 더 강한 그림자 */
        box-shadow: 0 -30px 60px rgba(0, 0, 0, 0.15);
        /* 더 명확한 덮어쓰기를 위한 배경 */
        background: linear-gradient(to bottom, #f7f4ea, #f0ede0);
      } /* 오버레이 모드 */
      .next h2 {
        margin: 0 0 12px;
        font-size: clamp(24px, 5vw, 48px);
      }
      .next p {
        max-width: 72ch;
        line-height: 1.7;
        opacity: 0.9;
      }

      /* 덮어쓰기 효과를 위한 추가 스타일 */
      .next::before {
        content: '';
        position: absolute;
        top: -20px;
        left: 0;
        right: 0;
        height: 20px;
        background: linear-gradient(to bottom, transparent, #f7f4ea);
        pointer-events: none;
      }

      /* 마지막 이미지가 고정된 상태에서 덮어쓰기 효과 강화 */
      .next.is-overlay::after {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        height: 100%;
        background: #f7f4ea;
        z-index: -1;
      }

      .next-ph {
        height: 0;
      } /* 오버레이 동안 레이아웃 유지용 플레이스홀더 */
    </style>
  </head>
  <body>
    <div class="spacer"><h2>위쪽 컨텐츠</h2></div>

    <section class="pin-wrap">
      <div class="stage" id="stage">
        <img src="https://picsum.photos/id/1018/1600/900" alt="" />
        <img src="https://picsum.photos/id/1025/1600/900" alt="" />
        <img src="https://picsum.photos/id/1035/1600/900" alt="" />
        <img src="https://picsum.photos/id/1043/1600/900" alt="" />
        <img src="https://picsum.photos/id/1050/1600/900" alt="" />
      </div>
    </section>

    <div class="next-ph" id="nextPH"></div>

    <section class="next" id="next">
      <h2>다음 섹션</h2>
      <p>
        아래 섹션이 패널 전환 단계에 맞춰 패럴럭스처럼 올라오며 위 스테이지를
        덮습니다.
      </p>
      <div style="height: 100vh"></div>
    </section>

    <script>
      gsap.registerPlugin(ScrollTrigger);

      const panels = gsap.utils.toArray('#stage img'); // 위→아래
      const steps = panels.length - 1; // 전환 횟수
      const seg = 1; // 각 단계 길이(타임라인 단위)
      const SPEED = 2.0; // 스크롤 길이 배수 (더 긴 스크롤)
      const SCRUB = 1.5; // 더 부드러운 스크럽

      // 아래 섹션(오버레이 토글)
      const next = document.getElementById('next');
      const nextPH = document.getElementById('nextPH');
      function setOverlay(on) {
        if (on) {
          console.log('setOverlay ON');
          nextPH.style.height = next.offsetHeight + 'px';
          next.classList.add('is-overlay');
          gsap.set(next, { yPercent: 100 });
          // 즉시 보이도록 강제 설정
          next.style.display = 'block';
          next.style.visibility = 'visible';
        } else {
          console.log('setOverlay OFF');
          next.classList.remove('is-overlay');
          gsap.set(next, { clearProps: 'transform' });
          nextPH.style.height = '0px';
        }
      }

      const tl = gsap.timeline({
        defaults: { ease: 'none' },
        scrollTrigger: {
          trigger: '.pin-wrap',
          start: 'top top',
          end: '+=' + window.innerHeight * steps * SPEED,
          scrub: SCRUB,
          pin: true,
          anticipatePin: 1,
          snap: {
            snapTo: (v) => Math.round(v * steps) / steps,
            duration: 0.35,
            ease: 'power1.inOut',
          },
        },
      });

      // 이미지 교차 전환 (마지막 이미지는 고정)
      panels.forEach((img, i) => {
        if (i === panels.length - 1) return; // 마지막(맨 아래)은 고정
        tl.to(img, { yPercent: -100, duration: seg }, i * seg);
      });

      // ===== 페럴랙스 덮어쓰기 =====
      // 이미지 전환이 끝나기 전에 next 섹션이 덮어쓰기 시작
      const COVER_START = 1; // 첫 번째 이미지 전환 후부터 시작
      const COVER_END = steps;

      // 덮어쓰기 시작 (첫 번째 이미지 전환 후)
      tl.call(
        () => {
          console.log('Overlay ON - 덮어쓰기 시작');
          setOverlay(true);
        },
        [],
        COVER_START * seg
      );

      // 점진적으로 위로 올라와서 덮어쓰기
      for (let i = COVER_START; i < COVER_END; i++) {
        const progress = (i - COVER_START) / (COVER_END - COVER_START);
        const y = gsap.utils.interpolate(100, 0, progress);

        console.log(`Step ${i}: progress=${progress}, y=${y}`);

        tl.to(
          next,
          {
            yPercent: y,
            duration: seg,
            ease: 'power2.out',
          },
          i * seg
        );
      }

      // 끝나면 오버레이 OFF
      tl.call(() => setOverlay(false), [], COVER_END * seg);

      // 뒤로 스크롤 시 다시 오버레이 유지 (더 부드럽게)
      ScrollTrigger.create({
        trigger: '.pin-wrap',
        start: 'bottom bottom',
        end: 'bottom top',
        onEnterBack: () => {
          setOverlay(true);
          // 뒤로 스크롤 시 그림자 효과 복원
          gsap.to(next, {
            boxShadow: '0 -30px 60px rgba(0, 0, 0, 0.15)',
            duration: 0.3,
            ease: 'power2.out',
          });
        },
        onLeave: () => {
          setOverlay(false);
          // 앞으로 스크롤 시 그림자 효과 제거
          gsap.to(next, {
            boxShadow: '0 -20px 40px rgba(0, 0, 0, 0.1)',
            duration: 0.3,
            ease: 'power2.out',
          });
        },
      });

      addEventListener('resize', () => {
        if (!next.classList.contains('is-overlay')) nextPH.style.height = '0px';
        ScrollTrigger.refresh();
      });
    </script>
  </body>
</html>
